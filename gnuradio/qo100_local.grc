options:
  parameters:
    author: DM6AS, DF7CB
    catch_exceptions: 'True'
    category: '[GRC Hier Blocks]'
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: qo100_local
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: qo100
    window_size: ''
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [32, 20.0]
    rotation: 0
    state: enabled

blocks:
- name: decim
  id: variable
  parameters:
    comment: ''
    value: '11'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [40, 124.0]
    rotation: 0
    state: enabled
- name: high_cutoff_gauge
  id: qtgui_levelgauge
  parameters:
    affinity: ''
    alias: ''
    backgroundColor: default
    barColor: default
    comment: ''
    fontColor: default
    gui_hint: 41,1,1,5
    isVertical: 'False'
    label: ''
    maximum: '3000'
    minimum: '0'
    msize: '100'
    position: '1'
    scaleFactor: '1'
    showValue: 'True'
    type: int
    value: '3000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1696, 292.0]
    rotation: 0
    state: true
- name: low_cutoff_gauge
  id: qtgui_levelgauge
  parameters:
    affinity: ''
    alias: ''
    backgroundColor: default
    barColor: default
    comment: ''
    fontColor: default
    gui_hint: 40,1,1,5
    isVertical: 'False'
    label: ''
    maximum: '3000'
    minimum: '0'
    msize: '100'
    position: '1'
    scaleFactor: '1'
    showValue: 'True'
    type: int
    value: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1696, 172.0]
    rotation: 0
    state: true
- name: mag
  id: variable
  parameters:
    comment: ''
    value: '0.9'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [376, 36.0]
    rotation: 0
    state: true
- name: qtgui_dialgauge_0
  id: qtgui_dialgauge
  parameters:
    affinity: ''
    alias: ''
    backgroundColor: white
    barColor: blue
    comment: WPM
    fontColor: black
    gui_hint: 39,5,1,1
    label: WPM
    maximum: '56'
    minimum: '0'
    msize: '80'
    position: '1'
    showValue: 'True'
    type: int
    value: '24'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1704, 820.0]
    rotation: 0
    state: enabled
- name: qtgui_dialgauge_1
  id: qtgui_dialgauge
  parameters:
    affinity: ''
    alias: ''
    backgroundColor: white
    barColor: blue
    comment: TX power
    fontColor: black
    gui_hint: 39,4,1,1
    label: TX Power
    maximum: '1.0'
    minimum: '0.0'
    msize: '80'
    position: '1'
    showValue: 'True'
    type: real
    value: '0.1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1696, 44.0]
    rotation: 0
    state: enabled
- name: qtgui_dialgauge_2
  id: qtgui_dialgauge
  parameters:
    affinity: ''
    alias: ''
    backgroundColor: white
    barColor: blue
    comment: AF gain
    fontColor: black
    gui_hint: 39,3,1,1
    label: AF Gain
    maximum: '1.5'
    minimum: '0.0'
    msize: '80'
    position: '1'
    showValue: 'True'
    type: real
    value: '1.0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1704, 436.0]
    rotation: 0
    state: enabled
- name: qtgui_dialgauge_3
  id: qtgui_dialgauge
  parameters:
    affinity: ''
    alias: ''
    backgroundColor: white
    barColor: blue
    comment: Filter Center
    fontColor: black
    gui_hint: 39,1,1,1
    label: Filter Center
    maximum: '3000'
    minimum: '0'
    msize: '80'
    position: '1'
    showValue: 'True'
    type: int
    value: '1500'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1704, 692.0]
    rotation: 0
    state: enabled
- name: qtgui_dialgauge_4
  id: qtgui_dialgauge
  parameters:
    affinity: ''
    alias: ''
    backgroundColor: white
    barColor: blue
    comment: Filter bandwidth
    fontColor: black
    gui_hint: 39,2,1,1
    label: Filter BW
    maximum: '3000'
    minimum: '0'
    msize: '80'
    position: '1'
    showValue: 'True'
    type: int
    value: '3000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1704, 564.0]
    rotation: 0
    state: enabled
- name: rx0_high_cutoff
  id: variable
  parameters:
    comment: 'RX bandpass

      high edge'
    value: '3000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1272, 308.0]
    rotation: 0
    state: true
- name: rx0_low_cutoff
  id: variable
  parameters:
    comment: 'RX bandpass

      low edge'
    value: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1272, 188.0]
    rotation: 0
    state: true
- name: samp_rate
  id: variable
  parameters:
    comment: ''
    value: decim*48e3
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [224, 36.0]
    rotation: 0
    state: enabled
- name: tx_power
  id: variable
  parameters:
    comment: TX power
    value: '1.0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1272, 60.0]
    rotation: 0
    state: true
- name: tx_vfo
  id: qtgui_msgdigitalnumbercontrol
  parameters:
    ThousandsSeparator: .
    affinity: ''
    alias: ''
    comment: TX VFO frequency display
    gui_hint: 40,0,2,1
    lbl: TX
    maxFreqHz: 510e3
    maxoutbuf: '0'
    minFreqHz: -10e3
    minoutbuf: '0'
    outputmsgname: freq
    readOnly: 'False'
    relBackgroundColor: black
    relFontColor: white
    value: 40e3
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1272, 428.0]
    rotation: 180
    state: true
- name: vfo
  id: qtgui_msgdigitalnumbercontrol
  parameters:
    ThousandsSeparator: .
    affinity: ''
    alias: ''
    comment: RX VFO frequency display
    gui_hint: 39,0,1,1
    lbl: RX
    maxFreqHz: 510e3
    maxoutbuf: '0'
    minFreqHz: -10e3
    minoutbuf: '0'
    outputmsgname: freq
    readOnly: 'False'
    relBackgroundColor: black
    relFontColor: white
    value: 40e3
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1280, 876.0]
    rotation: 180
    state: true
- name: zmq_watermark
  id: variable
  parameters:
    comment: ''
    value: '4'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [120, 124.0]
    rotation: 0
    state: enabled
- name: analog_sig_source_x_0
  id: analog_sig_source_x
  parameters:
    affinity: ''
    alias: ''
    amp: 1e-3
    comment: ''
    freq: rx0_low_cutoff
    maxoutbuf: '0'
    minoutbuf: '0'
    offset: '0'
    phase: '0'
    samp_rate: 24e3
    showports: 'False'
    type: complex
    waveform: analog.GR_COS_WAVE
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1280, 1340.0]
    rotation: 0
    state: enabled
- name: analog_sig_source_x_0_0
  id: analog_sig_source_x
  parameters:
    affinity: ''
    alias: ''
    amp: 1e-3
    comment: ''
    freq: rx0_high_cutoff
    maxoutbuf: '0'
    minoutbuf: '0'
    offset: '0'
    phase: '0'
    samp_rate: 24e3
    showports: 'False'
    type: complex
    waveform: analog.GR_COS_WAVE
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1280, 1476.0]
    rotation: 0
    state: enabled
- name: blocks_add_xx_0
  id: blocks_add_xx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_inputs: '2'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1592.0, 1328]
    rotation: 90
    state: enabled
- name: blocks_message_debug_0
  id: blocks_message_debug
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    en_uvec: 'True'
    log_level: info
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1656, 1016.0]
    rotation: 0
    state: disabled
- name: blocks_swapiq_0
  id: blocks_swapiq
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    datatype: complex
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [336, 560.0]
    rotation: 0
    state: true
- name: blocks_throttle2_0
  id: blocks_throttle2
  parameters:
    affinity: ''
    alias: ''
    comment: Frequency sink audio passband markers
    ignoretag: 'True'
    limit: auto
    maximum: '0.1'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_second: 24e3
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1280, 1260.0]
    rotation: 180
    state: enabled
- name: control
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\nimport pmt\n\nimport\
      \ os\nimport pulsectl\n\n# buttons (notes)\nMIDI_FT8_QRG = 2 # KP 2 A\nMIDI_SHIFT_FT8_QRG\
      \ = 6 # Shift-KP 2 A\nMIDI_SYNC_A = 35\nMIDI_SHIFT_SYNC_A = 38\nMIDI_RECORD\
      \ = 43\n\nMIDI_AUDIO_HEADPHONES = 49 # KP 1 B\nMIDI_AUDIO_SPEAKER = 51 # KP\
      \ 3 B\nMIDI_AUDIO_STEREO = 52 # KP 4 B\nMIDI_AUDIOS = [MIDI_AUDIO_HEADPHONES,\
      \ MIDI_AUDIO_STEREO, MIDI_AUDIO_SPEAKER]\n\n# controls\nMIDI_VFO_A = 48 # Jog\
      \ A\nMIDI_SHIFT_VFO_A = 55 # Shift-Jog A\nMIDI_POWER = 54 # Sync A\nMIDI_VOLUME\
      \ = 57 # Volume A\nMIDI_BANDPASS_CENTER = 59 # Medium A\nMIDI_BANDPASS_WIDTH\
      \ = 60 # Bass A\nMIDI_WPM = 0x3D\nMIDI_REPORT_ALL_CONTROLS = 0x7f\n\ndef sign(i):\n\
      \    if i < 0:\n        return -1\n    elif i > 0:\n        return 1\n    else:\n\
      \        return 0\n\nclass blk(gr.sync_block):\n    \"\"\"TRX Control block\"\
      \"\"\n\n    def __init__(self):  # only default arguments here\n        \"\"\
      \"arguments to this function show up as parameters in GRC\"\"\"\n        gr.sync_block.__init__(\n\
      \            self,\n            name='Control',\n            in_sig=None,\n\
      \            out_sig=None,\n        )\n\n        self.message_port_register_in(pmt.intern(\"\
      midi_in\"))\n        self.set_msg_handler(pmt.intern(\"midi_in\"), self.midi_in)\n\
      \        self.message_port_register_in(pmt.intern(\"rx_freq_in\"))\n       \
      \ self.set_msg_handler(pmt.intern(\"rx_freq_in\"), self.rx_freq_in)\n      \
      \  self.message_port_register_in(pmt.intern(\"tx_freq_in\"))\n        self.set_msg_handler(pmt.intern(\"\
      tx_freq_in\"), self.tx_freq_in)\n\n        self.message_port_register_out(pmt.intern(\"\
      midi_out\"))\n        self.message_port_register_out(pmt.intern(\"rx_freq_out\"\
      ))\n        self.message_port_register_out(pmt.intern(\"tx_freq_out\"))\n  \
      \      self.message_port_register_out(pmt.intern(\"wpm_out\"))\n        self.message_port_register_out(pmt.intern(\"\
      filter_center_out\"))\n        self.message_port_register_out(pmt.intern(\"\
      filter_bw_out\"))\n        self.message_port_register_out(pmt.intern(\"af_gain_out\"\
      ))\n\n        self.rx0_freq = 40000.0\n        self.tx_freq = 40000.0\n    \
      \    self.filter_center = 850\n        self.filter_bw = 3000\n        self.record\
      \ = False\n        self.sync_a = False # start false so set_sync_a sets the\
      \ LEDs\n        self.vfo_a_dir = 0 # last tuning direction\n\n        self.pulse\
      \ = None\n        self.tx_audio_port = None\n        self.rx_audio_port = None\n\
      \        self.ft8_audio_port = None\n\n    def note_on(self, note, velocity):\n\
      \        self.message_port_pub(pmt.intern(\"midi_out\"),\n                pmt.cons(pmt.intern('note_on'),\n\
      \                    pmt.cons(pmt.from_long(note), pmt.from_long(velocity))))\n\
      \n    def start(self):\n\n        # Audio\n        self.pulse = pulsectl.Pulse('qo100')\n\
      \n        for port in self.pulse.source_output_list():\n            # device.description:\
      \ ALSA Capture [python3.13]\n            desc = port.proplist.get('device.description')\n\
      \            if desc and desc.startswith(\"ALSA Capture [python\"):\n      \
      \          self.tx_audio_port = port\n                print(\"TX port:\", self.tx_audio_port)\n\
      \                self.set_audio_input('tx0')\n                break\n\n    \
      \    for port in self.pulse.sink_input_list():\n            # device.description:\
      \ ALSA Playback [python3.13]\n            desc = port.proplist.get('device.description')\n\
      \            if desc and desc.startswith(\"ALSA Playback [python\"):\n     \
      \           if \"remote.name\" in port.proplist: # \"pipewire-0\" on the FT8\
      \ sink\n                    self.ft8_audio_port = port\n                   \
      \ print(\"FT8 port:\", self.ft8_audio_port)\n                    # need to restore\
      \ volume since pipewire can't tell the ports apart and randomly remembers the\
      \ last setting from either\n                    self.ft8_audio_port.volume.value_flat\
      \ = 1.0\n                    self.pulse.sink_input_volume_set(self.ft8_audio_port.index,\
      \ self.ft8_audio_port.volume)\n                    # connect to rx2\n      \
      \              rx2_sink = self.pulse.get_sink_by_name(\"rx2\")\n           \
      \         self.pulse.sink_input_move(self.ft8_audio_port.index, rx2_sink.index)\n\
      \                elif self.rx_audio_port is None:\n                    self.rx_audio_port\
      \ = port\n                    print(\"RX port:\", self.rx_audio_port)\n    \
      \                # volume will be set by polling the current console settings\n\
      \                    # connect to sink\n                    self.set_audio_output(MIDI_AUDIO_SPEAKER,\
      \ 'Internes Audio')\n\n        # MIDI\n        self.set_sync_a(True)\n     \
      \   self.set_rx_freq(40000.0)\n        self.set_tx_freq(40000.0)\n        self.set_record(False)\n\
      \n        # read out knobs and slider on startup\n        self.message_port_pub(pmt.intern(\"\
      midi_out\"),\n                pmt.cons(pmt.intern('control_change'),\n     \
      \               pmt.cons(pmt.from_long(MIDI_REPORT_ALL_CONTROLS), pmt.from_long(127))))\n\
      \n        # without this, the spectrum display updates only once per second\
      \ (GR bug?)\n        #self.tb.vfo0_spectrum.set_fft_size(2048)\n\n        #\
      \ create temp directory\n        try: os.mkdir(\"/run/user/1000/gnuradio\")\n\
      \        except: pass\n\n    def set_audio_volume(self, new_volume):\n     \
      \   try:\n            #rx_sink = self.pulse.sink_default_get()\n           \
      \ #rx_sink.volume.value_flat = new_volume\n            #self.pulse.sink_volume_set(rx_sink.index,\
      \ rx_sink.volume)\n            self.rx_audio_port.volume.value_flat = new_volume\n\
      \            self.pulse.sink_input_volume_set(self.rx_audio_port.index, self.rx_audio_port.volume)\n\
      \            self.message_port_pub(pmt.intern(\"af_gain_out\"),\n          \
      \      pmt.cons(pmt.intern('value'), pmt.from_double(new_volume)))\n\n     \
      \   except Exception as e:\n            print(\"Error setting volume:\", e)\n\
      \n    def set_audio_output(self, midi_key, sink_name):\n        try:\n     \
      \       for sink in self.pulse.sink_list():\n                if sink_name in\
      \ sink.description:\n                    self.pulse.sink_input_move(self.rx_audio_port.index,\
      \ sink.index)\n                    break\n\n            for key in MIDI_AUDIOS:\n\
      \                self.note_on(key, 127 if key == midi_key else 0)\n\n      \
      \  except Exception as e:\n            print(f\"Error setting audio output to\
      \ {sink_name}:\", e)\n\n    def set_audio_input(self, source_name):\n      \
      \  try:\n            for source in self.pulse.source_list():\n             \
      \   if source.description.startswith(source_name):\n                    self.pulse.source_output_move(self.tx_audio_port.index,\
      \ source.index)\n                    break\n\n        except Exception as e:\n\
      \            print(f\"Error setting audio input to {source_name}:\", e)\n\n\
      \    def set_record(self, record):\n        self.record = record\n        self.note_on(MIDI_RECORD,\
      \ 127 if self.record else 0)\n        if self.record:\n            self.set_audio_input(self.pulse.source_default_get().description)\n\
      \        else:\n            self.set_audio_input('Monitor of tx0')\n\n    def\
      \ set_rx_freq(self, freq):\n        self.message_port_pub(pmt.intern(\"rx_freq_out\"\
      ),\n                pmt.cons(pmt.intern('freq'), pmt.from_double(freq)));\n\n\
      \    def set_tx_freq(self, freq):\n        self.message_port_pub(pmt.intern(\"\
      tx_freq_out\"),\n                pmt.cons(pmt.intern('freq'), pmt.from_double(freq)));\n\
      \n    def set_wpm(self, wpm):\n        self.message_port_pub(pmt.intern(\"wpm_out\"\
      ),\n                pmt.cons(pmt.intern('value'), pmt.from_double(wpm)));\n\n\
      \    def set_sync_a(self, sync_a):\n        if self.sync_a != sync_a:\n    \
      \        self.sync_a = sync_a\n            self.note_on(MIDI_SYNC_A, 127 if\
      \ sync_a else 0)\n            self.note_on(MIDI_SHIFT_SYNC_A, 127 if sync_a\
      \ else 0)\n            if sync_a:\n                self.set_tx_freq(self.rx0_freq)\n\
      \n    def rx_freq_in(self, msg):\n        if msg.is_pair() and pmt.car(msg)\
      \ == pmt.intern('freq'):\n            self.rx0_freq = int(pmt.to_double(pmt.cdr(msg)))\n\
      \            if self.sync_a:\n                self.set_tx_freq(self.rx0_freq)\n\
      \n    def tx_freq_in(self, msg):\n        if msg.is_pair() and pmt.car(msg)\
      \ == pmt.intern('freq'):\n            tx_freq = int(pmt.to_double(pmt.cdr(msg)))\n\
      \n            if (tx_freq == 40000) != (self.tx_freq == 40000):\n          \
      \      # FT8 frequency indicator LED\n                self.note_on(MIDI_FT8_QRG,\
      \ 127 if tx_freq == 40000 else 0)\n                self.note_on(MIDI_SHIFT_FT8_QRG,\
      \ 127 if tx_freq == 40000 else 0)\n\n            self.tx_freq = tx_freq\n\n\
      \            if self.tx_freq != self.rx0_freq:\n                self.set_sync_a(False)\n\
      \n            freqfile = open(\"/run/user/1000/gnuradio/qo100.qrg\", \"w\")\n\
      \            freqfile.write(str(tx_freq + 2400000000) + \"\\n\")\n         \
      \   # fake frequency on 10m so tlf can deal with it\n            #freqfile.write(str(tx_freq\
      \ + 28000000) + \"\\n\")\n            freqfile.close()\n\n    def midi_in(self,\
      \ msg):\n        if not msg.is_pair(): return\n        msgtype = str(pmt.car(msg))\n\
      \n        if msgtype == 'control_change':\n            payload = pmt.cdr(msg)\n\
      \            control = pmt.to_long(pmt.car(payload))\n            value = pmt.to_long(pmt.cdr(payload))\n\
      \n            if control == MIDI_VFO_A: # jog A\n                delta = value\
      \ if value < 64 else value - 128\n                if sign(delta) != self.vfo_a_dir:\
      \ # compensate for 2 (or 126) output on direction change\n                 \
      \   delta += self.vfo_a_dir\n                    self.vfo_a_dir = sign(delta)\n\
      \                self.set_rx_freq(self.rx0_freq + delta * 10)\n\n          \
      \  elif control == MIDI_SHIFT_VFO_A and value != 64: # shift-jog a (64 reported\
      \ on all-buttons-readout, ignore that)\n                delta = value if value\
      \ < 64 else value - 128\n                if sign(delta) != self.vfo_a_dir: #\
      \ compensate for 2 (or 126) output on direction change\n                   \
      \ delta += self.vfo_a_dir\n                    self.vfo_a_dir = sign(delta)\n\
      \                self.set_sync_a(False)\n                self.set_tx_freq(self.tx_freq\
      \ + delta * 10)\n\n            elif control == MIDI_VOLUME:\n              \
      \  self.set_audio_volume(value / 100.0) # 0 .. 127%\n\n            elif control\
      \ == MIDI_WPM:\n                wpm = round(6.0 + 42.0 * value / 127.0) # 0\
      \ .. 127% -> 6..48 wpm\n                self.set_wpm(wpm)\n\n            elif\
      \ control in (MIDI_BANDPASS_CENTER, MIDI_BANDPASS_WIDTH): # medium A, bass A\n\
      \                if control == MIDI_BANDPASS_CENTER:\n                    self.filter_center\
      \ = 1500 + 20 * (value - 64)\n                    self.message_port_pub(pmt.intern(\"\
      filter_center_out\"),\n                        pmt.cons(pmt.intern('value'),\
      \ pmt.from_double(self.filter_center)))\n                if control == MIDI_BANDPASS_WIDTH:\n\
      \                    if value < 127 - 36: # first 36 steps are 30Hz, the rest\
      \ 20Hz\n                        self.filter_bw = 3000 - 360 - 20 * (127 - value)\n\
      \                    else:\n                        self.filter_bw = 3000 -\
      \ 30 * (127 - value)\n                    self.message_port_pub(pmt.intern(\"\
      filter_bw_out\"),\n                        pmt.cons(pmt.intern('value'), pmt.from_double(self.filter_bw)))\n\
      \n                low_cutoff = max(self.filter_center - self.filter_bw // 2,\
      \ 0)\n                high_cutoff = min(self.filter_center + self.filter_bw\
      \ // 2, 3000)\n                self.tb.set_rx0_low_cutoff(low_cutoff)\n    \
      \            self.tb.set_rx0_high_cutoff(high_cutoff)\n\n            elif control\
      \ == MIDI_POWER:\n                power = 0.1 + 0.9 * (value/127.0)\n      \
      \          self.tb.set_tx_power(power)\n\n            else:\n              \
      \  print(\"Unknown MIDI control_change:\", control, value)\n\n        elif msgtype\
      \ == 'note_on':\n            payload = pmt.cdr(msg)\n            note = pmt.to_long(pmt.car(payload))\n\
      \            velocity = pmt.to_long(pmt.cdr(payload))\n\n            if velocity\
      \ != 127: # ignore key releases\n                return\n\n            if note\
      \ == MIDI_SYNC_A: # Sync A\n                self.set_sync_a(not self.sync_a)\n\
      \n            elif note == MIDI_SHIFT_SYNC_A: # Shift-Sync A\n             \
      \   if not self.sync_a:\n                    # set RX from TX\n            \
      \        self.set_rx_freq(self.tx_freq)\n                self.set_sync_a(not\
      \ self.sync_a)\n\n            elif note == MIDI_FT8_QRG: # KP 2 A\n        \
      \        self.set_rx_freq(40000)\n                self.set_sync_a(True)\n  \
      \              self.set_record(False)\n\n            elif note == MIDI_AUDIO_HEADPHONES:\
      \ # KP 1 A\n                self.set_audio_output(MIDI_AUDIO_HEADPHONES, 'Plantronics')\n\
      \n            elif note == MIDI_AUDIO_STEREO: # KP 3 A\n                self.set_audio_output(MIDI_AUDIO_STEREO,\
      \ 'Internes Audio Analog Stereo')\n\n            elif note == MIDI_AUDIO_SPEAKER:\
      \ # KP 4 A\n                self.set_audio_output(MIDI_AUDIO_SPEAKER, 'Unitek\
      \ Y')\n\n            elif note == MIDI_RECORD: # REC\n                self.set_record(not\
      \ self.record)\n\n            else:\n                print(\"Unknown MIDI note_on:\"\
      , note, velocity)\n\n        else:\n            print(\"Unknown MIDI message\
      \ type:\", msgtype)\n\nif __name__ == '__main__':\n    blk()\n"
    affinity: ''
    alias: ''
    comment: Control logic
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Control', 'blk', [], [('tx_freq_in', 'message', 1), ('rx_freq_in',
      'message', 1), ('midi_in', 'message', 1)], [('af_gain_out', 'message', 1), ('filter_bw_out',
      'message', 1), ('filter_center_out', 'message', 1), ('wpm_out', 'message', 1),
      ('tx_freq_out', 'message', 1), ('rx_freq_out', 'message', 1), ('midi_out', 'message',
      1)], 'TRX Control block', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1344, 560.0]
    rotation: 0
    state: true
- name: fosphor_glfw_sink_c_0
  id: fosphor_glfw_sink_c
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    freq_center: 250e3
    freq_span: samp_rate
    maxoutbuf: '0'
    minoutbuf: '0'
    wintype: window.WIN_BLACKMAN_hARRIS
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [904, 444.0]
    rotation: 0
    state: disabled
- name: ft4_sink
  id: blocks_wavfile_sink
  parameters:
    affinity: ''
    alias: ''
    append: 'False'
    bits_per_sample1: FORMAT_PCM_16
    bits_per_sample2: FORMAT_PCM_16
    bits_per_sample3: FORMAT_VORBIS
    bits_per_sample4: FORMAT_PCM_16
    comment: FT4 file output
    file: /dev/null
    format: FORMAT_WAV
    nchan: '1'
    samp_rate: '12000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [904, 1244.0]
    rotation: 180
    state: enabled
- name: ft84_cron
  id: epy_block
  parameters:
    _source_code: "from gnuradio import gr\nimport pmt\nimport time\nimport threading\n\
      \nclass blk(gr.basic_block):\n    \"\"\"Send Timed Msgs\"\"\"\n\n    def __init__(self):\n\
      \        \"\"\"arguments to this function show up as parameters in GRC\"\"\"\
      \n        gr.sync_block.__init__(\n            self,\n            name='Send\
      \ Timed Msgs',   # will show up in GRC\n            in_sig=None,\n         \
      \   out_sig=None,\n        )\n        self.message_port_register_out(pmt.intern(\"\
      cron_ft8\"))\n        self.message_port_register_out(pmt.intern(\"cron_ft4\"\
      ))\n\n    def start(self):\n        self.cron_thread = threading.Thread(target=self.cron_ft8,\
      \ daemon=True)\n        self.cron_thread.start()\n        self.cron_thread =\
      \ threading.Thread(target=self.cron_ft4, daemon=True)\n        self.cron_thread.start()\n\
      \n    def sleep(self, interval):\n        time.sleep(interval - (time.time()\
      \ % interval))\n        return True\n\n    def cron_ft8(self):\n        while\
      \ self.sleep(15):\n            self.message_port_pub(pmt.intern(\"cron_ft8\"\
      ), pmt.intern(\"rotate_ft8\"))\n\n    def cron_ft4(self):\n        while self.sleep(7.5):\n\
      \            self.message_port_pub(pmt.intern(\"cron_ft4\"), pmt.intern(\"rotate_ft4\"\
      ))\n\nif __name__ == \"__main__\":\n    b = blk()\n    b.cron_ft8()\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Send Timed Msgs', 'blk', [], [], [('cron_ft4', 'message', 1), ('cron_ft8',
      'message', 1)], 'Send Timed Msgs', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [288, 1232.0]
    rotation: 0
    state: true
- name: ft84_rotate
  id: epy_block
  parameters:
    _source_code: "from gnuradio import gr\nimport pmt\nimport os\nimport subprocess\n\
      import time\n\nclass blk(gr.basic_block):\n    \"\"\"Rotate wav files and feed\
      \ them to jt9 for FT8 and FT4 decoding\"\"\"\n\n    def __init__(self, tmp_path='.'):\n\
      \        \"\"\"arguments to this function show up as parameters in GRC\"\"\"\
      \n        gr.sync_block.__init__(\n            self,\n            name='Rotate\
      \ and Decode Wav File',   # will show up in GRC\n            in_sig=None,\n\
      \            out_sig=None,\n        )\n        self.tmp_path = tmp_path\n\n\
      \        self.message_port_register_in(pmt.intern(\"rotate_ft8\"))\n       \
      \ self.set_msg_handler(pmt.intern(\"rotate_ft8\"), self.rotate_ft8)\n      \
      \  self.message_port_register_in(pmt.intern(\"rotate_ft4\"))\n        self.set_msg_handler(pmt.intern(\"\
      rotate_ft4\"), self.rotate_ft4)\n\n        # remember if we saw decodes in the\
      \ last cycle\n        self.decode = { 'ft8': False, 'ft4': False }\n\n    def\
      \ start(self):\n        # store all decodes in file in PWD\n        self.all_txt\
      \ = open(\"ft84.txt\", \"a\")\n        self.conn = None\n        self.cur =\
      \ None\n\n        # change to tmp_path (jt9 leaves a few temp files around there)\n\
      \        try: os.mkdir(self.tmp_path)\n        except: pass\n        os.chdir(self.tmp_path)\n\
      \n    def handle_line(self, mode, stamp, line):\n        # jt9 out: 000000 \
      \  3  0.3 1743 ~  CQ DF7CB JO31\n        # ALL.TXT: 220321_131530  2400.040\
      \ Rx FT8      1  0.5  523 ES2KO LY1FX 73\n        fields = line.split(None,\
      \ 5)\n        if len(fields) > 5 and fields[0] == \"000000\":\n            try:\n\
      \                db = int(fields[1])\n                dt = float(fields[2])\n\
      \                freq = int(fields[3])\n                prefix = f\"{stamp}\
      \ 2400.040 Rx {mode.upper()}\"\n                data = f\" {db:+3} {dt:+4} {freq:4}\
      \ \"\n                msg = fields[5].rstrip()\n\n                # file output\n\
      \                self.all_txt.write(prefix + data + msg + \"\\n\")\n       \
      \         self.all_txt.flush()\n\n                # terminal output\n      \
      \          if mode == 'ft8':\n                    if stamp[-2:] in ('00', '30'):\n\
      \                        stampcolor = \"\\033[48;5;39m\"\n                 \
      \   else:\n                        stampcolor = \"\\033[48;5;42m\"\n       \
      \         elif mode == 'ft4':\n                    if stamp[-2:] in ('00', '15',\
      \ '30', '45'):\n                        stampcolor = \"\\033[48;5;208m\"\n \
      \                   else:\n                        stampcolor = \"\\033[48;5;220m\"\
      \n                if msg.startswith(\"DF7CB \"): # received my call\n      \
      \              start, end = \"\\033[48;5;226m\", \"\\033[0m\"\n            \
      \    elif \"DF7CB\" in msg: # sent by myself\n                    start, end\
      \ = \"\\033[41m\", \"\\033[0m\"\n                else:\n                   \
      \ start, end = \"\", \"\"\n                print(f\"{stampcolor}{prefix}\\033[0m{data}{start}{msg}{end}\"\
      , flush=True)\n\n                return True # successful decode\n         \
      \   except:\n                pass\n        return False\n\n    def rotate_and_decode(self,\
      \ mode, sink, interval):\n        tmp_file = f\"{mode}-tmp.wav\"\n        decode_file\
      \ = f\"{mode}.wav\"\n\n        # rotate file\n        try: os.unlink(decode_file)\n\
      \        except: pass\n        try: os.rename(tmp_file, decode_file)\n     \
      \   except: pass\n\n        # ask sink to re-open file\n        sink.open(tmp_file)\n\
      \n        stamp = time.strftime('%F_%H%M%S', time.gmtime(time.time() - interval))\n\
      \n        # decode it\n        res = subprocess.run([\"jt9\", \"--\" + mode,\
      \ decode_file], capture_output=True)\n        out = res.stdout.decode()\n\n\
      \        decode = False\n        for line in out.split(\"\\n\"):\n         \
      \   # decode a line\n            decode |= self.handle_line(mode, stamp, line)\n\
      \n        # insert a separator line if we saw something in the last cycle, but\
      \ this cycle was empty\n        if not decode and self.decode[mode]:\n     \
      \       print(flush=True)\n        self.decode[mode] = decode\n\n    def rotate_ft8(self,\
      \ msg):\n        self.rotate_and_decode(\"ft8\", self.tb.ft8_sink, 15)\n\n \
      \   def rotate_ft4(self, msg):\n        self.rotate_and_decode(\"ft4\", self.tb.ft4_sink,\
      \ 7.5)\n"
    affinity: ''
    alias: ''
    comment: FT8/FT4 decoder control logic
    maxoutbuf: '0'
    minoutbuf: '0'
    tmp_path: '''/run/user/1000/gnuradio'''
  states:
    _io_cache: ('Rotate and Decode Wav File', 'blk', [('tmp_path', "'.'")], [('rotate_ft4',
      'message', 1), ('rotate_ft8', 'message', 1)], [], 'Rotate wav files and feed
      them to jt9 for FT8 and FT4 decoding', ['tmp_path'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [576, 1264.0]
    rotation: 0
    state: enabled
- name: ft8_sink
  id: blocks_wavfile_sink
  parameters:
    affinity: ''
    alias: ''
    append: 'False'
    bits_per_sample1: FORMAT_PCM_16
    bits_per_sample2: FORMAT_PCM_16
    bits_per_sample3: FORMAT_VORBIS
    bits_per_sample4: FORMAT_PCM_16
    comment: FT8 file output
    file: /dev/null
    format: FORMAT_WAV
    nchan: '1'
    samp_rate: '12000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [904, 1372.0]
    rotation: 180
    state: true
- name: inject_tb
  id: snippet
  parameters:
    alias: ''
    code: '# make top block accessible in control block

      self.control.tb = self

      # make top block accessible in ft84_rotate block

      self.ft84_rotate.tb = self'
    comment: ''
    priority: '0'
    section: main_after_init
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [464, 36.0]
    rotation: 0
    state: true
- name: limesdr_source
  id: limesdr_source
  parameters:
    affinity: ''
    alias: ''
    allow_tcxo_dac: '0'
    analog_bandw_ch0: 1.5e6
    analog_bandw_ch1: 5e6
    calibr_bandw_ch0: 5e6
    calibr_bandw_ch1: 5e6
    ch_align: 'False'
    channel_mode: '0'
    comment: Receiver
    dacVal: '125'
    digital_bandw_ch0: '0'
    digital_bandw_ch1: '0'
    filename: ''
    gain_dB_ch0: '30'
    gain_dB_ch1: '30'
    lna_path_ch0: '2'
    lna_path_ch1: '2'
    maxoutbuf: '0'
    minoutbuf: '0'
    nco_freq_ch0: '0'
    nco_freq_ch1: '0'
    oversample: '0'
    rf_freq: 739.75e6
    samp_rate: samp_rate
    serial: ''
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [40, 436.0]
    rotation: 0
    state: disabled
- name: midi_block
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\nimport pmt\nimport\
      \ mido\nimport threading\n\nclass blk(gr.sync_block):\n    \"\"\"MIDI Source\
      \ block\"\"\"\n\n    def __init__(self, midi_port='DJControl Compact:DJControl\
      \ Compact DJControl Com'):  # only default arguments here\n        \"\"\"arguments\
      \ to this function show up as parameters in GRC\"\"\"\n        gr.sync_block.__init__(\n\
      \            self,\n            name='MIDI Source',\n            in_sig=None,\n\
      \            out_sig=None,\n        )\n        self.midi_port = midi_port\n\n\
      \        self.message_port_register_in(pmt.intern(\"midi_in\"))\n        self.set_msg_handler(pmt.intern(\"\
      midi_in\"), self.midi_message)\n        self.message_port_register_out(pmt.intern(\"\
      midi_out\"))\n\n    def start(self):\n        self.midiport = mido.open_ioport(self.midi_port)\n\
      \n        self.midithread = threading.Thread(target=self.midi, daemon=True)\n\
      \        self.midithread.start()\n\n    def midi(self):\n        for msg in\
      \ self.midiport:\n\n            if msg.type == 'control_change':\n         \
      \       self.message_port_pub(pmt.intern(\"midi_out\"),\n                  \
      \      pmt.cons(pmt.intern('control_change'),\n                            pmt.cons(pmt.from_long(msg.control),\
      \ pmt.from_long(msg.value))))\n\n            elif msg.type == 'note_on':\n \
      \               self.message_port_pub(pmt.intern(\"midi_out\"),\n          \
      \              pmt.cons(pmt.intern('note_on'),\n                           \
      \ pmt.cons(pmt.from_long(msg.note), pmt.from_long(msg.velocity))))\n       \
      \     else:\n                self.message_port_pub(pmt.intern(\"midi_out\"),\
      \ pmt.string_to_symbol(str(msg)))\n\n    def midi_message(self, msg):\n    \
      \    if not msg.is_pair(): return\n        msgtype = str(pmt.car(msg))\n\n \
      \       if msgtype == 'note_on':\n            payload = pmt.cdr(msg)\n     \
      \       note = pmt.to_long(pmt.car(payload))\n            velocity = pmt.to_long(pmt.cdr(payload))\n\
      \n            self.midiport.send(mido.Message('note_on', note=note, velocity=velocity))\n\
      \n        elif msgtype == 'control_change':\n            payload = pmt.cdr(msg)\n\
      \            control = pmt.to_long(pmt.car(payload))\n            value = pmt.to_long(pmt.cdr(payload))\n\
      \n            self.midiport.send(mido.Message('control_change', control=control,\
      \ value=value))\n\nif __name__ == '__main__':\n    blk()\n"
    affinity: ''
    alias: ''
    comment: MIDI interface
    maxoutbuf: '0'
    midi_port: '''DJControl Compact'''
    minoutbuf: '0'
  states:
    _io_cache: ('MIDI Source', 'blk', [('midi_port', "'DJControl Compact:DJControl
      Compact DJControl Com'")], [('midi_in', 'message', 1)], [('midi_out', 'message',
      1)], 'MIDI Source block', ['midi_port'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1248, 812.0]
    rotation: 180
    state: true
- name: rational_resampler_4
  id: rational_resampler_xxx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    decim: '4'
    fbw: '0'
    interp: '1'
    maxoutbuf: '0'
    minoutbuf: '0'
    taps: '[]'
    type: fff
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [936, 1140.0]
    rotation: 0
    state: true
- name: rigctld
  id: epy_block
  parameters:
    _source_code: "from gnuradio import gr\nimport pmt\n\nimport socket\nimport threading\n\
      import re\n\nclass Client(threading.Thread):\n    def __init__(self, sock, address,\
      \ block):\n        threading.Thread.__init__(self)\n        self.socket = sock\n\
      \        self.address = address\n        self.block = block\n\n        self.band\
      \ = 2_400_000_000 # remember the band the client wants to be on\n        self.mode\
      \ = \"USB\"\n\n    def reply(self, msg):\n        self.socket.sendall((msg +\
      \ \"\\r\\n\").encode(\"UTF-8\"))\n\n    def run(self):\n        try:\n     \
      \       while True:\n                data = self.socket.recv(128)\n        \
      \        if len(data) == 0:\n                    self.socket.close()\n     \
      \               break\n\n                cmd = str(data.decode(\"utf-8\")).strip()\n\
      \                #print(\"rigctld:\", cmd)\n\n                if cmd == \"\"\
      :\n                    pass\n                elif m := re.match(r\"f\\b\", cmd):\n\
      \                    freq = self.band + self.block.freq\n                  \
      \  if self.mode == \"CW\":\n                        freq += 850\n          \
      \          self.reply(str(freq))\n                elif m := re.match(r\"F\\\
      s*(\\d+)\\b\", cmd):\n                    freq = int(m.group(1))\n         \
      \           if self.mode == \"CW\":\n                        freq -= 850\n \
      \                   base_freq = freq % 500_000\n                    self.band\
      \ = freq - base_freq\n                    self.block.message_port_pub(pmt.intern(\"\
      freq_out\"),\n                                                pmt.cons(pmt.intern('control_change'),\
      \ pmt.from_long(base_freq)))\n                    self.reply(\"RPRT 0\")\n \
      \               elif m := re.match(r\"l\\s*KEYSPD\\b\", cmd):\n            \
      \        self.reply(str(self.block.wpm))\n                elif m := re.match(r\"\
      m\\b\", cmd):\n                    self.reply(self.mode)\n                 \
      \   self.reply(\"3000\")\n                elif m := re.match(r\"M\\s*(\\S+)\\\
      s+.+\\b\", cmd):\n                    self.mode = m.group(1)\n             \
      \       self.reply(\"RPRT 0\")\n                elif m := re.match(r\"q\\b\"\
      , cmd):\n                    self.reply(\"RPRT 0\")\n                    self.socket.close()\n\
      \                    break\n                elif m := re.match(r\"s\\b\", cmd):\
      \ # split mode\n                    self.reply(\"0\")\n                    self.reply(\"\
      None\")\n                elif m := re.match(r\"v\\b\", cmd):\n             \
      \       self.reply(\"VFOA\")\n                elif m := re.match(r\"V\\s*.+\\\
      b\", cmd):\n                    self.reply(\"RPRT 0\")\n                elif\
      \ m := re.match(r\"\\\\chk_vfo\\b\", cmd):\n                    self.reply(\"\
      0\")\n                elif m := re.match(r\"\\\\get_lock_mode\\b\", cmd):\n\
      \                    self.reply(\"0\")\n                    self.reply(\"RPRT\
      \ 0\")\n                elif m := re.match(r\"\\\\get_powerstat\\b\", cmd):\n\
      \                    self.reply(\"1\")\n                elif m := re.match(r\"\
      \\\\dump_state\\b\", cmd):\n                    self.reply(\"\"\"\\\n1\n1\n\
      0\n150000.000000 1500000000.000000 0x1ff -1 -1 0x17e00007 0xf\n0 0 0 0 0 0 0\n\
      150000.000000 1500000000.000000 0x1ff 5000 100000 0x17e00007 0xf\n0 0 0 0 0\
      \ 0 0\n0x1ff 1\n0x1ff 0\n0 0\n0xc 2400\n0xc 1800\n0xc 3000\n0xc 0\n0x2 500\n\
      0x2 2400\n0x2 50\n0x2 0\n0x10 300\n0x10 2400\n0x10 50\n0x10 0\n0x1 8000\n0x1\
      \ 2400\n0x1 10000\n0x20 15000\n0x20 8000\n0x40 230000\n0 0\n9990\n9990\n10000\n\
      0\n10 \n10 20 30 \n0xffffffffffffffff\n0xffffffffffffffff\n0xfffffffff7ffffff\n\
      0xfffeff7083ffffff\n0xffffffffffffffff\n0xffffffffffffffbf\"\"\")\n        \
      \            self.reply(\"done\")\n                else:\n                 \
      \   print(\"Unknown rigctld command:\", cmd)\n                    self.reply(\"\
      RPRT -1\")\n        except Exception as inst:\n            print(inst)\n   \
      \         pass\n\n        print(\"rigctld: client \" + str(self.address) + \"\
      \ has disconnected\")\n\ndef newConnections(socket, block):\n    #connections\
      \ = []\n    #total_connections = 0\n\n    while True:\n        sock, address\
      \ = socket.accept()\n        print(\"rigctld: new connection from\", address)\n\
      \        Client(sock, address, block).start()\n\nclass blk(gr.sync_block):\n\
      \    \"\"\"Hamlib rigctld interface block\"\"\"\n\n    def __init__(self, port=4536):\n\
      \        \"\"\"arguments to this function show up as parameters in GRC\"\"\"\
      \n        gr.sync_block.__init__(\n            self,\n            name='Hamlib\
      \ rigctld interface',\n            in_sig=None,\n            out_sig=None,\n\
      \        )\n\n        self.port = port\n\n        self.freq = 0\n        self.wpm\
      \ = 0\n\n        self.message_port_register_in(pmt.intern(\"freq_in\"))\n  \
      \      self.set_msg_handler(pmt.intern(\"freq_in\"), self.freq_in)\n       \
      \ self.message_port_register_in(pmt.intern(\"wpm_in\"))\n        self.set_msg_handler(pmt.intern(\"\
      wpm_in\"), self.wpm_in)\n\n        self.message_port_register_out(pmt.intern(\"\
      freq_out\"))\n\n        self.tcpthread = threading.Thread(target=self.tcp, daemon=True)\n\
      \        self.tcpthread.start()\n\n    #def start(self):\n\n    def freq_in(self,\
      \ msg):\n        if msg.is_pair() and pmt.car(msg) == pmt.intern('freq'):\n\
      \            self.freq = int(pmt.to_double(pmt.cdr(msg)))\n\n    def wpm_in(self,\
      \ msg):\n        if msg.is_pair() and pmt.car(msg) == pmt.intern('value'):\n\
      \            self.wpm = int(pmt.to_double(pmt.cdr(msg)))\n\n    def tcp(self):\n\
      \        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.setsockopt(socket.SOL_SOCKET,\
      \ socket.SO_REUSEADDR, 1)\n        sock.bind((\"localhost\", self.port))\n \
      \       sock.listen(5)\n\n        newConnectionsThread = threading.Thread(target\
      \ = newConnections, args = (sock, self))\n        newConnectionsThread.start()\n\
      \nif __name__ == '__main__':\n    blk()\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    port: '4555'
  states:
    _io_cache: ('Hamlib rigctld interface', 'blk', [('port', '4536')], [('wpm_in',
      'message', 1), ('freq_in', 'message', 1)], [('freq_out', 'message', 1)], 'Hamlib
      rigctld interface block', ['port'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1296, 1008.0]
    rotation: 0
    state: enabled
- name: rx0_high_cutoff_to_msg
  id: blocks_var_to_msg
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    msgname: value
    target: rx0_high_cutoff
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1400, 308.0]
    rotation: 0
    state: true
- name: rx0_low_cutoff_to_msg
  id: blocks_var_to_msg
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    msgname: value
    target: rx0_low_cutoff
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1400, 188.0]
    rotation: 0
    state: true
- name: rx_freq_sink
  id: qtgui_freq_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    average: '0.1'
    axislabels: 'True'
    bw: samp_rate
    color1: '"blue"'
    color10: '"dark blue"'
    color2: '"red"'
    color3: '"green"'
    color4: '"black"'
    color5: '"cyan"'
    color6: '"magenta"'
    color7: '"yellow"'
    color8: '"dark red"'
    color9: '"dark green"'
    comment: ''
    ctrlpanel: 'False'
    fc: 250e3
    fftsize: '1024'
    freqhalf: 'True'
    grid: 'False'
    gui_hint: ''
    label: Relative Gain
    label1: ''
    label10: ''''''
    label2: ''''''
    label3: ''''''
    label4: ''''''
    label5: ''''''
    label6: ''''''
    label7: ''''''
    label8: ''''''
    label9: ''''''
    legend: 'True'
    maxoutbuf: '0'
    minoutbuf: '0'
    name: '""'
    nconnections: '1'
    norm_window: 'False'
    showports: 'False'
    tr_chan: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_tag: '""'
    type: complex
    units: dB
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    wintype: window.WIN_BLACKMAN_hARRIS
    ymax: '-50'
    ymin: '-75'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [288, 396.0]
    rotation: 0
    state: disabled
- name: rx_resampler
  id: rational_resampler_xxx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    decim: '1'
    fbw: '0'
    interp: decim
    maxoutbuf: '0'
    minoutbuf: '0'
    taps: '[]'
    type: ccc
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [704, 212.0]
    rotation: 0
    state: enabled
- name: rx_waterfall
  id: qtgui_waterfall_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    axislabels: 'True'
    bw: samp_rate
    color1: '0'
    color10: '0'
    color2: '0'
    color3: '0'
    color4: '0'
    color5: '0'
    color6: '0'
    color7: '0'
    color8: '0'
    color9: '0'
    comment: Transponder waterfall
    fc: 250e3
    fftsize: '2048'
    freqhalf: 'True'
    grid: 'False'
    gui_hint: 0,0,14,6
    int_max: '-50'
    int_min: '-80'
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    maxoutbuf: '0'
    minoutbuf: '0'
    name: '""'
    nconnections: '1'
    showports: 'True'
    type: complex
    update_time: '0.15'
    wintype: window.WIN_BLACKMAN_hARRIS
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [896, 544.0]
    rotation: 0
    state: true
- name: tx_audio_source
  id: audio_source
  parameters:
    affinity: ''
    alias: ''
    comment: Transmitter audio input
    device_name: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_outputs: '1'
    ok_to_block: 'False'
    samp_rate: '48000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [40, 212.0]
    rotation: 0
    state: enabled
- name: tx_bandpass
  id: band_pass_filter
  parameters:
    affinity: ''
    alias: ''
    beta: '6.76'
    comment: ''
    decim: '1'
    gain: tx_power
    high_cutoff_freq: '3000'
    interp: '1'
    low_cutoff_freq: '0'
    maxoutbuf: '0'
    minoutbuf: '0'
    samp_rate: 48e3
    type: interp_fir_filter_ccc
    width: '200'
    win: window.WIN_HAMMING
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [464, 180.0]
    rotation: 0
    state: enabled
- name: tx_mixer
  id: blocks_multiply_xx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_inputs: '2'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [896, 248.0]
    rotation: 0
    state: enabled
- name: tx_power_to_msg
  id: blocks_var_to_msg
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    msgname: value
    target: tx_power
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1400, 60.0]
    rotation: 0
    state: true
- name: tx_to_complex
  id: blocks_float_to_complex
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [280, 232.0]
    rotation: 0
    state: enabled
- name: tx_vfo_signal_source
  id: analog_sig_source_x
  parameters:
    affinity: ''
    alias: ''
    amp: mag
    comment: TX VFO
    freq: tx_vfo - 250e3
    maxoutbuf: '0'
    minoutbuf: '0'
    offset: '0'
    phase: '0'
    samp_rate: samp_rate
    showports: 'False'
    type: complex
    waveform: analog.GR_COS_WAVE
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [600, 364.0]
    rotation: 0
    state: enabled
- name: vfo0_audio_sink
  id: audio_sink
  parameters:
    affinity: ''
    alias: ''
    comment: 'Main audio output

      (Device name empty)'
    device_name: ''
    num_inputs: '1'
    ok_to_block: 'False'
    samp_rate: '48000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [952, 868.0]
    rotation: 0
    state: true
- name: vfo0_bandpass
  id: band_pass_filter
  parameters:
    affinity: ''
    alias: ''
    beta: '6.76'
    comment: Audio output
    decim: decim
    gain: '20'
    high_cutoff_freq: rx0_high_cutoff
    interp: '1'
    low_cutoff_freq: rx0_low_cutoff
    maxoutbuf: '0'
    minoutbuf: '0'
    samp_rate: samp_rate
    type: fir_filter_ccc
    width: '100'
    win: window.WIN_HAMMING
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [480, 836.0]
    rotation: 0
    state: true
- name: vfo0_mixer
  id: blocks_multiply_xx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_inputs: '2'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [312, 872.0]
    rotation: 0
    state: enabled
- name: vfo0_scope_bandpass
  id: band_pass_filter
  parameters:
    affinity: ''
    alias: ''
    beta: '6.76'
    comment: ''
    decim: 2*decim
    gain: '1'
    high_cutoff_freq: 12e3
    interp: '1'
    low_cutoff_freq: -12e3
    maxoutbuf: '0'
    minoutbuf: '0'
    samp_rate: samp_rate
    type: fir_filter_ccc
    width: '1000'
    win: window.WIN_HAMMING
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [480, 644.0]
    rotation: 0
    state: true
- name: vfo0_signal_source
  id: analog_sig_source_x
  parameters:
    affinity: ''
    alias: ''
    amp: mag
    comment: 'VFO 0: main receiver'
    freq: 250e3-vfo
    maxoutbuf: '0'
    minoutbuf: '0'
    offset: '0'
    phase: '0'
    samp_rate: samp_rate
    showports: 'False'
    type: complex
    waveform: analog.GR_COS_WAVE
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [40, 724.0]
    rotation: 0
    state: enabled
- name: vfo0_spectrum
  id: qtgui_freq_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    average: '0.2'
    axislabels: 'True'
    bw: 24e3
    color1: '"blue"'
    color10: '"dark blue"'
    color2: '"red"'
    color3: '"green"'
    color4: '"black"'
    color5: '"cyan"'
    color6: '"magenta"'
    color7: '"yellow"'
    color8: '"dark red"'
    color9: '"dark green"'
    comment: Spectrum around VFO 0
    ctrlpanel: 'False'
    fc: 40e3
    fftsize: '2048'
    freqhalf: 'True'
    grid: 'True'
    gui_hint: 15,0,14,6
    label: Relative Gain
    label1: ''
    label10: ''''''
    label2: ''''''
    label3: ''''''
    label4: ''''''
    label5: ''''''
    label6: ''''''
    label7: ''''''
    label8: ''''''
    label9: ''''''
    legend: 'False'
    maxoutbuf: '0'
    minoutbuf: '0'
    name: ''
    nconnections: '2'
    norm_window: 'True'
    showports: 'True'
    tr_chan: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_tag: '""'
    type: complex
    units: dB
    update_time: '0.01'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    wintype: window.WIN_HAMMING
    ymax: '-50'
    ymin: '-94'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1280, 1096.0]
    rotation: 0
    state: enabled
- name: vfo0_to_float
  id: blocks_complex_to_float
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [752, 872.0]
    rotation: 0
    state: true
- name: vfo0_waterfall_add
  id: blocks_add_xx
  parameters:
    affinity: ''
    alias: ''
    comment: Display VFO 0 in waterfall
    maxoutbuf: '0'
    minoutbuf: '0'
    num_inputs: '2'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [688, 528.0]
    rotation: 0
    state: true
- name: vfo0_waterfall_atten
  id: blocks_multiply_const_vxx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    const: '0.01'
    maxoutbuf: '0'
    minoutbuf: '0'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [496, 556.0]
    rotation: 0
    state: true
- name: vfo2_audio_sink
  id: audio_sink
  parameters:
    affinity: ''
    alias: ''
    comment: "FT8/FT4 audio output\n(Device name \"pipewire\" \nso we can tell it\
      \ apart \nfrom the main output)"
    device_name: pipewire
    num_inputs: '1'
    ok_to_block: 'False'
    samp_rate: '48000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [936, 1036.0]
    rotation: 0
    state: true
- name: vfo2_bandpass
  id: band_pass_filter
  parameters:
    affinity: ''
    alias: ''
    beta: '6.76'
    comment: FT8/FT4 output
    decim: decim
    gain: '10'
    high_cutoff_freq: '5000'
    interp: '1'
    low_cutoff_freq: '0'
    maxoutbuf: '0'
    minoutbuf: '0'
    samp_rate: samp_rate
    type: fir_filter_ccc
    width: '1000'
    win: window.WIN_HAMMING
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [480, 1012.0]
    rotation: 0
    state: true
- name: vfo2_mixer
  id: blocks_multiply_xx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_inputs: '2'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [312, 1048.0]
    rotation: 0
    state: enabled
- name: vfo2_signal_source
  id: analog_sig_source_x
  parameters:
    affinity: ''
    alias: ''
    amp: mag
    comment: 'VFO 2: FT8/FT4 receiver'
    freq: 250e3-40e3
    maxoutbuf: '0'
    minoutbuf: '0'
    offset: '0'
    phase: '0'
    samp_rate: samp_rate
    showports: 'False'
    type: complex
    waveform: analog.GR_COS_WAVE
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [40, 1028.0]
    rotation: 0
    state: enabled
- name: vfo2_to_float
  id: blocks_complex_to_float
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [736, 1048.0]
    rotation: 0
    state: true
- name: zeromq_pull_source_0
  id: zeromq_pull_source
  parameters:
    address: tcp://192.168.0.11:10010
    affinity: ''
    alias: ''
    bind: 'False'
    comment: ''
    hwm: zmq_watermark
    maxoutbuf: '0'
    minoutbuf: '0'
    pass_tags: 'False'
    timeout: '100'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [40, 620.0]
    rotation: 0
    state: enabled
- name: zeromq_push_sink_0
  id: zeromq_push_sink
  parameters:
    address: tcp://0.0.0.0:10024
    affinity: ''
    alias: ''
    bind: 'True'
    comment: ''
    hwm: zmq_watermark
    pass_tags: 'False'
    timeout: '100'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1024, 228.0]
    rotation: 0
    state: enabled

connections:
- [analog_sig_source_x_0, '0', blocks_add_xx_0, '0']
- [analog_sig_source_x_0_0, '0', blocks_add_xx_0, '1']
- [blocks_add_xx_0, '0', blocks_throttle2_0, '0']
- [blocks_swapiq_0, '0', vfo0_waterfall_atten, '0']
- [blocks_throttle2_0, '0', vfo0_spectrum, '1']
- [control, af_gain_out, qtgui_dialgauge_2, value]
- [control, filter_bw_out, qtgui_dialgauge_4, value]
- [control, filter_center_out, qtgui_dialgauge_3, value]
- [control, midi_out, midi_block, midi_in]
- [control, rx_freq_out, vfo, valuein]
- [control, tx_freq_out, tx_vfo, valuein]
- [control, wpm_out, qtgui_dialgauge_0, value]
- [control, wpm_out, rigctld, wpm_in]
- [ft84_cron, cron_ft4, ft84_rotate, rotate_ft4]
- [ft84_cron, cron_ft8, ft84_rotate, rotate_ft8]
- [limesdr_source, '0', rx_freq_sink, '0']
- [limesdr_source, '0', vfo0_mixer, '0']
- [limesdr_source, '0', vfo0_waterfall_add, '0']
- [limesdr_source, '0', vfo2_mixer, '0']
- [midi_block, midi_out, blocks_message_debug_0, print]
- [midi_block, midi_out, control, midi_in]
- [rational_resampler_4, '0', ft4_sink, '0']
- [rational_resampler_4, '0', ft8_sink, '0']
- [rigctld, freq_out, vfo, valuein]
- [rx0_high_cutoff_to_msg, msgout, high_cutoff_gauge, value]
- [rx0_low_cutoff_to_msg, msgout, low_cutoff_gauge, value]
- [rx_resampler, '0', tx_mixer, '0']
- [rx_waterfall, freq, vfo, valuein]
- [tx_audio_source, '0', tx_to_complex, '0']
- [tx_bandpass, '0', rx_resampler, '0']
- [tx_mixer, '0', zeromq_push_sink_0, '0']
- [tx_power_to_msg, msgout, qtgui_dialgauge_1, value]
- [tx_to_complex, '0', tx_bandpass, '0']
- [tx_vfo, valueout, control, tx_freq_in]
- [tx_vfo_signal_source, '0', tx_mixer, '1']
- [vfo, valueout, control, rx_freq_in]
- [vfo, valueout, rigctld, freq_in]
- [vfo, valueout, vfo0_spectrum, freq]
- [vfo0_bandpass, '0', vfo0_to_float, '0']
- [vfo0_mixer, '0', vfo0_bandpass, '0']
- [vfo0_mixer, '0', vfo0_scope_bandpass, '0']
- [vfo0_scope_bandpass, '0', vfo0_spectrum, '0']
- [vfo0_signal_source, '0', blocks_swapiq_0, '0']
- [vfo0_signal_source, '0', vfo0_mixer, '1']
- [vfo0_spectrum, freq, vfo, valuein]
- [vfo0_spectrum, freq, vfo0_spectrum, freq]
- [vfo0_to_float, '0', vfo0_audio_sink, '0']
- [vfo0_waterfall_add, '0', rx_waterfall, '0']
- [vfo0_waterfall_atten, '0', vfo0_waterfall_add, '1']
- [vfo2_bandpass, '0', vfo2_to_float, '0']
- [vfo2_mixer, '0', vfo2_bandpass, '0']
- [vfo2_signal_source, '0', vfo2_mixer, '1']
- [vfo2_to_float, '0', rational_resampler_4, '0']
- [vfo2_to_float, '0', vfo2_audio_sink, '0']
- [zeromq_pull_source_0, '0', fosphor_glfw_sink_c_0, '0']
- [zeromq_pull_source_0, '0', vfo0_mixer, '0']
- [zeromq_pull_source_0, '0', vfo0_waterfall_add, '0']
- [zeromq_pull_source_0, '0', vfo2_mixer, '0']

metadata:
  file_format: 1
  grc_version: 3.10.12.0
